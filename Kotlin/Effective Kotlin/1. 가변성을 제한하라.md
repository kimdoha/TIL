# 1장. 안정성(Safety)
코틀린은 **안정성**이 있는 언어입니다. 따라서 애플리케이션의 잠재적인 오류를 줄여줍니다.  
코틀린이 제공하는 기능을 알아보고, 이를 올바르게 사용하는 방법 즉, **오류가 덜 발생하는 코드를 만드는 것** 을 알아봅니다.

``` kotlin
class BankAccount {
	var balance = 0.0
	private set

	fun deposit(depositAmount: Double) {      // 예금
		balance += depositAmount
	}
	
	@Throws(InsufficientFunds::class)
	fun withdraw(withdrawAmount: Double) {    // 출금
		if (balance < withdrawAmount) {
			throw InsufficientFunds()
		}
		balance -= withdrawAmount
	}
}

class InsufficientFunds : Exception()
val account = BankAccount()
println(account.balance) // 0.0
account.deposit(100.0)
println(account.balance) // 100.0
account.withdraw(50.0)
println(account.balance) // 50.0
```
위 BankAccount에서 balance는 돈이 얼마나 있는지 나타내는 상태입니다. 상태를 적절하게 관리하는 것은 어렵습니다.

## Item 1. 가변성을 제한하라
- 읽기 전용 프로퍼티 **val**
- **가변 컬렉션**과 **읽기 전용 컬렉션** 구분하기
- 데이터 클래스의 **copy**

### 1. 읽기 전용 프로퍼티(val)
읽기 전용 프로퍼티는 `val`, 읽고 쓸 수 있는 프로퍼티는 `var` 로 만듭니다.
``` kotlin
val a = 10
a = 20 // 오류
```

읽기 전용 프로퍼티가 완전히 변경 불가능한 것은 아니지만 **가변 컬렉션**과 **읽기 전용 컬렉션**을 구분해서 사용합니다.

``` kotlin
val list = mutableListOf(1,2,3)
list.add(4)
print(list) // [1, 2, 3, 4]
```


코틀린의 프로퍼티는 기본적으로 캡슐화되어 있고,  
추가적으로 사용자 정의 접근자 (**getter**, **setter**)를 가질 수 있습니다.  
- **var** - 게터와 세터 모두 제공
- **val** - 게터만 제공

```kotlin
interface Element {
  var active: Boolean
}

class ActualElement: Element {
  override var active: Boolean = false
}
```

**val** 은 변경할 수 없음(불변, immutable)을 의미하는 것은 아닙니다.  
만약 완전히 변경할 필요가 없다면 **final** 프로퍼티를 사용하는 것이 좋습니다.  
- `fullName`은 게터로 정의하였으므로 **스마트 캐스트** 할 수 없습니다.
``` kotlin
val name: String? = "Marton"
val surname: String = "Braun"

val fullName: String?
    get() = name?.let { "$it $surname" }

val fullName2: String? = name?.let { "$it $surname" }

fun main() {
   if(fullName != null) {
	println(fullName.length) // 오류
   }

   if(fullname2 != null) {
	println(fullName2.length) // Marton braun
   }
}
```

### 2. 가변 컬렉션과 읽기 전용 컬렉션 구분하기
코틀린은 **읽고 쓸 수 있는 프로퍼티**와 **읽기 전용 프로퍼티**로 구분됩니다.   
마찬가지로 코틀린은 **읽고 쓸 수 있는 컬렉션**과 **읽기 전용 컬렉션**으로 구분됩니다.  

<img width="930" alt="image" src="https://github.com/kimdoha/TIL/assets/62235737/26bc4191-116d-4819-a0fe-4ca8ade94fa5">

코틀린은 내부적으로 Immutable하지 않은 컬렉션을 외부적으로 Immutable하게 보이도록 만들어서 안정성을 얻습니다.  
**즉, 리스트를 읽기 전용으로 리턴하면, 읽기 전용으로만 사용해야 합니다.**
읽기 전용에서 mutable로 변경해야 한다면, 복제(copy)를 통해서 새로운 mutable 컬렉션을 만드는 `list.toMutableList` 를 활용해야 합니다.  
``` kotlin
val list = listOf(1,2,3)

val mutableList = list.toMutableList()
mutable.add(4)
```
